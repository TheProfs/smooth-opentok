<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="video-stream.html">
<script src="https://static.opentok.com/v2/js/opentok.min.js"></script>

<!--
`smooth-opentok`
Opentok&#39;s API wrapped as a Polymer element for sane humans

@demo demo/index.html
-->

<dom-module id="smooth-opentok">
  <style>
    video-stream {
      width: 150px;
      height: 200px;
    }
  </style>

  <template>
    <!--@TODO
      Remove this it's only for dev purposes.
      This element should render nothing, it only publishes it's properties.
      `<video-stream>`s should be rendered externally.
    -->
    <template is="dom-repeat" items="{{streams}}">
      <video-stream
        stream="{{item}}"
        on-request-fullscreen="_makeFullScreen">
      </video-stream>
    </template>
    <!--/@TODO-->
  </template>

  <script>
    Polymer({

      is: 'smooth-opentok',

      properties: {
        streams: {
          type: Array,
          value: function() {
            return []
          },
          notify: true
        },

        screenSharingCapability: {
          type: Object,
          value: function() {
            return {}
          },
          notify: true
        },

        extensionsInformation: {
          type: Array,
          value: function() {
            return [
              {
                browser: 'chrome',
                id: 'fjdpgnenpoklmkcobgbnfnelpafdjhpp',
                version: 2
              }
            ]
          },
          observer: '_initScreensharing'
        },

        credentials: {
          type: Object,
          value: function() {
            return {
              api_key: 45990672,
              session_id: '1_MX40NTk5MDY3Mn5-MTUzNjE2MjE3MzA1Mn5lR1ZWRWJid0ZoVldDeStwYlNMMUVNeVd-fg',
              token: 'T1==cGFydG5lcl9pZD00NTk5MDY3MiZzaWc9NTk2OGRjYWY3ZTc0NmMyNjRmMjk4ZTU3ODUwZjdkNWFkNWU5ODg3NTpzZXNzaW9uX2lkPTFfTVg0ME5UazVNRFkzTW41LU1UVXpOakUyTWpFM016QTFNbjVsUjFaV1JXSmlkMFpvVmxkRGVTdHdZbE5NTVVWTmVWZC1mZyZjcmVhdGVfdGltZT0xNTM2MTYyMTczJm5vbmNlPTAuNzUxNDY3MTIxOTExNjI0OSZyb2xlPXB1Ymxpc2hlciZleHBpcmVfdGltZT0xNTM4NTgxMzczJmluaXRpYWxfbGF5b3V0X2NsYXNzX2xpc3Q9'
            }
          },
          observer: '_initSession'
        }
      },

      attached: function() {
        window.smoothOpentok = this
      },

      startCall: function() {
        this.publisher = this._createPublisher('camera')
      },

      stopCall: function() {
        this.session.disconnect()
        this.set('streams', [])
      },

      startScreenSharing: function() {
        this._setScreenSharingCapability()

        if (!this.screenSharingCapability.supported) {
          return this._handleCustomRTCError({
            code: 0,
            message: 'Screen-sharing not supported on this browser'
          })
        } else if (!this.screenSharingCapability.extensionRegistered) {
          return this._handleCustomRTCError({
            code: 0,
            message: 'Extension not registered'
          })
        } else if (this.screenSharingCapability.extensionRequired &&
            !this.screenSharingCapability.extensionInstalled) {
          console.info('Requesting screen share extension installation...')
          return this.fire('request-screen-share-extension-installation')
        }

        this.screenSharingPublisher = this._createPublisher('screen')
      },

      stopScreenSharing: function() {
        this.session.unpublish(this.screenSharingPublisher)
      },

      _createPublisher: function(videoSource = 'camera') {
        const publisher = OT.initPublisher(null, {
          videoSource: videoSource === 'camera' ? undefined : videoSource,
          publishVideo: videoSource === 'camera' ? false : undefined,
          insertDefaultUI: false
        }, this._handleRTCError.bind(this))

        if (this.session.isConnected()) {
          this.session.publish(publisher, this._handleRTCError.bind(this))
        } else {
          this.session.connect(this.credentials.token, err => {
            if (err) return this._handleRTCError(error)

            this.session.publish(publisher, this._handleRTCError.bind(this))
          })
        }

        publisher.on('videoElementCreated', e => {
          publisher.on('streamCreated', () => {
            this.push('streams', Object.assign(publisher.stream, {
              element: e.element
            }))
          })
        })

        publisher.on('streamDestroyed', e => {
          const i = this.streams.findIndex(item => item.id === e.stream.id)
          this.splice('streams', i, 1)
        })

        return publisher
      },

      _initSession: function(credentials) {
        this.session = OT.initSession(
          credentials.api_key,
          credentials.session_id
        )

        this.session.on('streamCreated', e => {
          const subscriber = this.session.subscribe(e.stream, null, {
            insertDefaultUI: false
          }, this._handleRTCError.bind(this))

          subscriber.on('videoElementCreated', e => {
            this.push('streams', Object.assign(subscriber.stream, {
              element: e.element
            }))
          })
        })

        this.session.on('streamDestroyed', e => {
          const i = this.streams.findIndex(item => item.id === e.stream.id)
          this.splice('streams', i, 1)
        })

        this.session.on('streamPropertyChanged', e => {
          const i = this.streams.findIndex(item => item.id === e.stream.id)
          this.set(`streams.${i}.${e.changedProperty}`, e.newValue)
        })
      },

      _initScreensharing: function(extensionsInformation) {
        this._registerScreenSharingExtensions(extensionsInformation)
        this._setScreenSharingCapability()
      },

      _registerScreenSharingExtensions: function(extensionsInformation) {
        extensionsInformation.forEach(info => {
          OT.registerScreenSharingExtension(info.browser, info.id, info.version)
        })
      },

      _setScreenSharingCapability: function() {
        OT.checkScreenSharingCapability(res => {
          this.set('screenSharingCapability', res)
        })
      },

      _handleCustomRTCError: function(err) {
        console.error(err)

        return this._handleRTCError()
      },

      _handleRTCError: function(err) {
        if (!err) return

        this.fire('error', err)
      }
    });
  </script>
</dom-module>
