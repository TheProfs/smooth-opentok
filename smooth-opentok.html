<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<script src="https://static.opentok.com/v2/js/opentok.min.js"></script>

<!--
`smooth-opentok`
Opentok&#39;s API wrapped as a Polymer element for sane humans

@demo demo/index.html
-->

<dom-module id="smooth-opentok">
  <template>
    <iron-ajax
      id="rtcSessionAjax"
      method="POST"
      url="[[getRtcTokenUrl]]"
      last-response="{{credentials}}"
      on-response="_handleCredentialRetrieval"
      on-error="_handleCredentialRetrievalError">
    </iron-ajax>
  </template>

  <script>
    Polymer({

      is: 'smooth-opentok',

      properties: {
        getRtcTokenUrl: {
          type: String
        },

        session: {
          type: Object,
          notify: true
        },

        publisher: {
          type: Object,
          notify: true
        },

        screenSharingPublisher: {
          type: Object,
          notify: true
        },

        streams: {
          type: Array,
          value: function() {
            return []
          },
          notify: true
        },

        screenSharingCapability: {
          type: Object,
          value: function() {
            return {}
          },
          notify: true
        },

        extensionsInformation: {
          type: Array,
          value: function() {
            return [
              {
                browser: 'chrome',
                id: 'fjdpgnenpoklmkcobgbnfnelpafdjhpp',
                version: 2
              }
            ]
          },
          observer: '_initScreensharing'
        },

        credentials: {
          type: Object,
          value: function() {
            return undefined
          }
        }
      },

      attached: function() {
        window.smoothOpentok = this
        this.$.rtcSessionAjax.generateRequest()
      },

      startCall: function() {
        this.set('publisher', this._createPublisher('camera'))
      },

      stopCall: function() {
        this.session.disconnect()
        this.set('streams', [])
      },

      startScreenSharing: function() {
        this._setScreenSharingCapability()

        if (!this.screenSharingCapability.supported) {
          return this._handleCustomRTCError({
            code: 0,
            message: 'Screen-sharing not supported on this browser'
          })
        } else if (!this.screenSharingCapability.extensionRegistered) {
          return this._handleCustomRTCError({
            code: 0,
            message: 'Extension not registered'
          })
        } else if (this.screenSharingCapability.extensionRequired &&
            !this.screenSharingCapability.extensionInstalled) {
          console.info('Requesting screen share extension installation...')
          return this.fire('request-screen-share-extension-installation')
        }

        this.set('screenSharingPublisher', this._createPublisher('screen'))
      },

      stopScreenSharing: function() {
        this.session.unpublish(this.screenSharingPublisher)
      },

      _createPublisher: function(videoSource = 'camera') {
        const publisher = OT.initPublisher(null, {
          videoSource: videoSource === 'camera' ? undefined : videoSource,
          publishVideo: videoSource === 'camera' ? false : undefined,
          insertDefaultUI: false
        }, this._handleRTCError.bind(this))

        if (this.session.isConnected()) {
          this.session.publish(publisher, this._handleRTCError.bind(this))
        } else {
          this.session.connect(this.credentials.token, err => {
            if (err) return this._handleRTCError(error)

            this.session.publish(publisher, this._handleRTCError.bind(this))
          })
        }

        publisher.on('videoElementCreated', e => {
          publisher.on('streamCreated', () => {
            this.push('streams', Object.assign(publisher.stream, {
              element: e.element
            }))
          })
        })

        publisher.on('streamDestroyed', e => {
          const i = this.streams.findIndex(item => item.id === e.stream.id)
          this.splice('streams', i, 1)
        })

        return publisher
      },

      _initSession: function(credentials) {
        this.set('session', OT.initSession(
          credentials.api_key,
          credentials.session_id
        ))

        this.session.on('streamCreated', e => {
          const subscriber = this.session.subscribe(e.stream, null, {
            insertDefaultUI: false
          }, this._handleRTCError.bind(this))

          subscriber.on('videoElementCreated', e => {
            this.push('streams', Object.assign(subscriber.stream, {
              element: e.element
            }))
          })
        })

        this.session.on('streamDestroyed', e => {
          const i = this.streams.findIndex(item => item.id === e.stream.id)
          this.splice('streams', i, 1)
        })

        this.session.on('streamPropertyChanged', e => {
          const i = this.streams.findIndex(item => item.id === e.stream.id)
          this.set(`streams.${i}.${e.changedProperty}`, e.newValue)
        })
      },

      _initScreensharing: function(extensionsInformation) {
        this._registerScreenSharingExtensions(extensionsInformation)
        this._setScreenSharingCapability()
      },

      _registerScreenSharingExtensions: function(extensionsInformation) {
        extensionsInformation.forEach(info => {
          OT.registerScreenSharingExtension(info.browser, info.id, info.version)
        })
      },

      _setScreenSharingCapability: function() {
        OT.checkScreenSharingCapability(res => {
          this.set('screenSharingCapability', res)
        })
      },

      _handleCredentialRetrieval: function(e) {
        this._initSession(e.detail.response)
      },

      _handleCredentialRetrievalError: function(err) {
        return this._handleCustomRTCError({
          code: 0,
          message: err.detail.error.stack
        })
      },

      _handleCustomRTCError: function(err) {
        return this._handleRTCError()
      },

      _handleRTCError: function(err) {
        if (!err) return

        this.fire('error', err)
      }
    });
  </script>
</dom-module>
