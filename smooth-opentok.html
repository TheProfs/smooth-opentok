<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="video-stream.html">
<script src="https://static.opentok.com/v2/js/opentok.min.js"></script>

<!--
`smooth-opentok`
Opentok&#39;s API wrapped as a Polymer element for sane humans

@demo demo/index.html
-->

<dom-module id="smooth-opentok">
  <style>
    video-stream {
      width: 150px;
      height: 200px;
    }
  </style>
  <template>
    <template is="dom-repeat" items="{{streams}}">
      <video-stream
        data-stream-id$="[[item.id]]"
        stream="{{item}}"
        hero$="[[!index]]"
        on-request-fullscreen="_makeFullScreen">
      </video-stream>
    </template>
  </template>

  <script>
    Polymer({

      is: 'smooth-opentok',

      properties: {
        streams: {
          type: Array,
          value: function() {
            return []
          },
          notify: true
        },

        credentials: {
          type: Object,
          value: function() {
            return {
              api_key: 45990672,
              session_id: '1_MX40NTk5MDY3Mn5-MTUzNjE2MjE3MzA1Mn5lR1ZWRWJid0ZoVldDeStwYlNMMUVNeVd-fg',
              token: 'T1==cGFydG5lcl9pZD00NTk5MDY3MiZzaWc9NTk2OGRjYWY3ZTc0NmMyNjRmMjk4ZTU3ODUwZjdkNWFkNWU5ODg3NTpzZXNzaW9uX2lkPTFfTVg0ME5UazVNRFkzTW41LU1UVXpOakUyTWpFM016QTFNbjVsUjFaV1JXSmlkMFpvVmxkRGVTdHdZbE5NTVVWTmVWZC1mZyZjcmVhdGVfdGltZT0xNTM2MTYyMTczJm5vbmNlPTAuNzUxNDY3MTIxOTExNjI0OSZyb2xlPXB1Ymxpc2hlciZleHBpcmVfdGltZT0xNTM4NTgxMzczJmluaXRpYWxfbGF5b3V0X2NsYXNzX2xpc3Q9'
            }
          }
        }
      },

      ready: function() {
        window.smoothOpentok = this
      },

      attached: function() {
        OT.registerScreenSharingExtension(
          'chrome',
          'fjdpgnenpoklmkcobgbnfnelpafdjhpp',
          2
        )

        this.session = OT.initSession(
          this.credentials.api_key,
          this.credentials.session_id
        )

        this.session.on('streamCreated', e => {
          const subscriber = this.session.subscribe(e.stream, null, {
            insertDefaultUI: false
          }, this._handleRTCError.bind(this))

          subscriber.on('videoElementCreated', e => {
            this.push('streams', Object.assign(subscriber.stream, {
              element: e.element
            }))
          })
        })

        this.session.on('streamDestroyed', e => {
          const i = this.streams.findIndex(item => item.id === e.stream.id)
          this.splice('streams', i, 1)
        })

        this.session.on('streamPropertyChanged', e => {
          const i = this.streams.findIndex(item => item.id === e.stream.id)
          this.set(`streams.${i}.${e.changedProperty}`, e.newValue)
        })
      },

      startCall: function() {
        this.publisher = this._createPublisher('camera')
      },

      stopCall: function() {
        this.session.disconnect()
        this.set('streams', [])
      },

      startScreenshare: function() {
        OT.checkScreenSharingCapability(res => {
          if (!res.supported || !res.extensionRegistered) {
            // @TODO Properly handle browser not supporting screen-sharing.
            console.error('Browser does not support screen-sharing')
          } else if (res.extensionRequired && !res.extensionInstalled) {
            // @TODO Properly handle extension not installed
            // (or non-HTTPS, or non-allowed site in extension manifest.json)
            console.error('Extension not installed OR site not added in manifest.json allowed domains OR site is not https://')
          } else {
            this.screenSharingPublisher = this._createPublisher('screen')
          }
        })
      },

      stopScreenshare: function() {
        this.session.unpublish(this.screenSharingPublisher)
      },

      _createPublisher: function(videoSource = 'camera') {
        const publisher = OT.initPublisher(null, {
          videoSource: videoSource === 'camera' ? undefined : videoSource,
          publishVideo: videoSource === 'camera' ? false : undefined,
          insertDefaultUI: false
        }, this._handleRTCError.bind(this))

        if (this.session.isConnected()) {
          this.session.publish(publisher, this._handleRTCError.bind(this))
        } else {
          this.session.connect(this.credentials.token, err => {
            if (err) return this._handleRTCError(error)

            this.session.publish(publisher, this._handleRTCError.bind(this))
          })
        }

        publisher.on('videoElementCreated', e => {
          publisher.on('streamCreated', () => {
            this.push('streams', Object.assign(publisher.stream, {
              element: e.element
            }))
          })
        })

        publisher.on('streamDestroyed', e => {
          const i = this.streams.findIndex(item => item.id === e.stream.id)
          this.splice('streams', i, 1)
        })

        return publisher
      },

      _handleRTCError: function(err) {
        // @TODO Figure out a way to handle errors.
        if (!err) return

        console.error(err)
      }
    });
  </script>
</dom-module>
