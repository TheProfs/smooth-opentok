<link rel="import" href="../polymer/polymer.html">

<script src="https://static.opentok.com/v2/js/opentok.min.js"></script>
<script src="classes/user.js"></script>

<!--
`smooth-opentok`
Opentok&#39;s API wrapped as a Polymer element for sane humans

@demo demo/index.html
-->

<dom-module id="smooth-opentok">
  <template>
    <template
      id="repeater"
      is="dom-repeat"
      items="{{users}}">
      <video-stream user="{{item}}" hidden$="[[!item.isConnected]]"></video-stream>
    </template>
  </template>

  <script>
    Polymer({

      is: 'smooth-opentok',

      properties: {
        users: {
          type: Array,
          value: function() {
            return []
          },
          notify: true
        },

        getRtcTokenUrl: {
          type: String
        },

        session: {
          type: Object,
          notify: true
        },

        screenSharingCapability: {
          type: Object,
          value: function() {
            return {}
          },
          notify: true
        },

        extensionsInformation: {
          type: Array,
          value: function() {
            return [
              {
                browser: 'chrome',
                id: 'nfiighcfoehnhiapoaonedebnoigkieo',
                version: 2
              }
            ]
          },
          observer: '_initScreensharing'
        },

        credentials: {
          type: Object,
          value: function() {
            return undefined
          }
        }
      },

      attached: function() {
        window.smoothOpentok = this
        this.idUser = Math.random().toString()
      },

      init: async function(credentials) {
        this.set('credentials', await this._fetchCredentials(this.getRtcTokenUrl))
        this.set('session', OT.initSession(
          this.credentials.api_key,
          this.credentials.session_id
        ))

        this.session.on('streamCreated', e => {
          this._upsertStreamToUser(e.stream)

          if (this._iAmInCall()) {
            this._subscribeToUnsubscribedStreams()
          }
        })

        this.session.on('streamDestroyed', e => {
          this._removeUser(e.stream)
        })

        this.session.on('streamPropertyChanged', e => {
          const path = this._getStreamPathById(e.stream.id)

          if (!path) return

          this.set(`${path}.${e.changedProperty}`, e.newValue)
        })

        return this._connectToSession(this.session, this.credentials.token)
      },

      startCall: function() {
        return this._createPublisher('camera')
         .then(() => {
           return this._subscribeToUnsubscribedStreams()
         })
      },

      stopCall: function() {
        this._unsubscribeFromAllStreams()
      },

      publishVideo: function() {
        const me = this._findMe()

        me.streams.camera.publisher.publishVideo(true)

        if (me.streams.screen) {
          this.stopScreenSharing()
        }
      },

      startScreenSharing: function() {
        this._setScreenSharingCapability()

        if (!this.screenSharingCapability.supported) {
          throw new Error('Screen-sharing not supported on this browser')
        } else if (!this.screenSharingCapability.extensionRegistered) {
          throw new Error('Extension not registered')
        } else if (this.screenSharingCapability.extensionRequired &&
            !this.screenSharingCapability.extensionInstalled) {
          console.info('Requesting screen share extension installation...')
          return this.fire('request-screen-share-extension-installation')
        }

        return this._createPublisher('screen')
      },

      stopScreenSharing: function() {
        const me = this._findMe()

        this.session.unpublish(me.streams.screen.publisher)
      },

      _createPublisher: async function(videoSource = 'camera') {
        if (!this.session.isConnected())
          throw new Error('Session not connected yet. Has init() resolved?')

        return new Promise((resolve) => {
          const publisher = OT.initPublisher(null, {
            videoSource: videoSource === 'camera' ? undefined : videoSource,
            publishVideo: false,
            insertDefaultUI: false,
            name: this.idUser
          }, err => {
            if (err) return reject(err)
          })

          publisher.on('streamDestroyed', e => {
            this._removeUser(e.stream)
          })

          publisher.on('videoElementCreated', e => {
            publisher.on('streamCreated', () => {
              this._upsertStreamToUser(publisher.stream)
              this._setUserAsSubscribed(publisher.stream, e.element.srcObject)
              resolve()
            })
          })

          this.session.publish(publisher, err => {
            if (err) return console.error(err)
          })
        })
      },

      _upsertStreamToUser: function(stream) {
        const existing = this.users.find(user => user.name === stream.name)

        const user = existing ? existing : new User(stream.name)

        if (!existing) {
          this.push('users', user)
        }

        const i = this.users.findIndex(user => user.name === stream.name)

        this.set(`users.${i}.streams.${stream.videoType}`, stream)

        if (this._isMe(user)) {
          this.set(`users.${i}.isConnected`, true)
        }

        if (stream.videoType === 'screen' && this._isMe(user)) {
          const me = this._findMe()
          me.streams.camera.publisher.publishVideo(false)
        }
      },

      _removeUser: function(stream) {
        switch (stream.videoType) {
          case 'camera':
            const i = this.users.findIndex(item => item.name === stream.name)

            this.splice('users', i, 1)
            break;
          case 'screen':
            const j = this.users.findIndex(item => item.name === stream.name)

            if (j === -1) return

            const isMe = this.users[j].name === this.idUser
            this.set(`users.${j}.streams.${stream.videoType}`, null)

            if (isMe) {
              const me = this._findMe()
              me.streams.camera.publisher.publishVideo(true)
            }
            break;
          default:
            console.warn('Cannot determine stream type')
        }
      },

      _setUserAsSubscribed: function(stream, srcObject) {
        const i = this.users.findIndex(item => item.name === stream.name)

        this.set(`users.${i}.streams.${stream.videoType}.srcObject`, srcObject)
      },

      _fetchCredentials: function(url) {
        return fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json; charset=utf-8'
          }
        })
        .then(response => response.json())
      },

      _connectToSession(session, token) {
        return new Promise((resolve, reject) => {
          session.connect(token, err => {
            if (err) return reject(err)

            resolve()
          })
        })
      },

      _initScreensharing: function(extensionsInformation) {
        this._registerScreenSharingExtensions(extensionsInformation)
        this._setScreenSharingCapability()
      },

      _registerScreenSharingExtensions: function(extensionsInformation) {
        extensionsInformation.forEach(info => {
          OT.registerScreenSharingExtension(info.browser, info.id, info.version)
        })
      },

      _setScreenSharingCapability: function() {
        OT.checkScreenSharingCapability(res => {
          this.set('screenSharingCapability', res)
        })
      },

      _subscribeToUnsubscribedStreams: async function() {
        for (let i = 0; i < this.users.length; i++) {
          const user = this.users[i]

          if (user.isPublisher()) continue

          for (const key in user.streams) {
            if (user.streams.hasOwnProperty(key) && user.streams[key]) {
              const stream = user.streams[key]

              if (stream.publisher) continue

              const result = await this._getSrcObjectForSubscribingStream(stream)
              const i = this.users.findIndex(user => user.name === stream.name)

              this.set(`users.${i}.streams.${stream.videoType}.srcObject`, result.srcObject)
              this.set(`users.${i}.streams.${stream.videoType}.subscriber`, result.subscriber)
            }
          }

          this.set(`users.${i}.isConnected`, true)
        }
      },

      _unsubscribeFromAllStreams: function() {
        this.users.forEach((user, i) => {
          Object.values(user.streams)
            .filter(stream => stream)
            .forEach(stream => {
              if (this._isMe(user)) {
                this.session.unpublish(stream.publisher)
              } else {
                this.session.unsubscribe(stream.subscriber)
              }
            })

          this.set(`users.${i}.isConnected`, false)
        })
      },

      _getSrcObjectForSubscribingStream: function(stream) {
        return new Promise((resolve, reject) => {
          const subscriber = this.session.subscribe(stream, null, {
            insertDefaultUI: false
          }, err => {
            if (err) return reject(err)
          })

          subscriber.once('videoElementCreated', e => {
            const subscribers = this.session.getSubscribersForStream(
              subscriber.stream
            )

            resolve({
              srcObject: e.element.srcObject,
              subscriber: subscribers.length ? subscribers[0] : undefined
            })
          })
        })
      },

      _getStreamPathById: function(streamId) {
        const userIndex = this.users.findIndex(user =>
          Object.values(user.streams)
          .find(stream => stream && stream.id === streamId))

        if (userIndex === -1) return false

        const streamKey =  Object.keys(this.users[userIndex].streams)
          .filter(key => this.users[userIndex].streams[key])
          .reduce((path, key) => {
            return !path && this.users[userIndex].streams[key].id === streamId
              ? key
              : null
          }, null)

        return streamKey ? `users.${userIndex}.streams.${streamKey}` : false
      },

      _findMe: function() {
        return this.users.find(user => user.name === this.idUser)
      },

      _isMe: function(user) {
        return user.name === this.idUser
      },

      _iAmInCall: function() {
        return this._findMe()
      }
    });
  </script>
</dom-module>
